# -*- coding: utf-8 -*-
"""Bitcoin_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TeyNtbea_6cwN-w23Tmx5Xr4ePjudehq

# 1.. Lets Read data & perform basic analysis !
"""

import pandas as pd # data pre-processing, CSV file I/O (e.g. pd.read_csv)
import numpy as np # import it for numerical computation on data
import matplotlib.pyplot as plt ## data viz libraries
import seaborn as sns

import os
from google.colab import files
uploaded = files.upload()

import pandas as pd
df = pd.read_csv('bitcoin_price_Training - Training.csv')
print(df.head())

df.head(3)

df.columns

df.shape

df.info()

df.describe().T

"""# 2.. Doing Data Pre-processing !
        Check whether data-types are correct or not
        check whether Data have missing value or not
        check whether data have duplicate entries or not !
        
"""

df.dtypes

"""    Date is to be in Date-time format inorder to perform a time series analysis but In the current dataset
    the date is stated as an object which is to be converted in the date time format..
"""

'''
pandas Data Type for Time-Series :
    a ) datetime64[ns]
datetime64[ns] is a 64 bit number ie it uses/occupies 64 bits or 8-Bytes in computer memory to store datetime value ..

    b ) datetime64[ns, tz]

    c ) datetime64[ns, UTC]


    d ) dtype('<M8[ns]') or dtype('>M8[ns]')

## < represents byte order, small end （ the least significant byte is stored in the smallest address ）
## M is a type character code for Datetime
## 8 represents element byte length, data size ie 8-byte or 64 bit




    where UTC = Coordinated Universal Time
          ns  = nano second
          tz  = time zone


'''

'''

datetime64[ns] is a general dtype, while dtype('<M8[ns]') is a specific dtype ,

Both are similar , it entirely depends upon how your numpy was compiled & on the bit architecture of the OS ..

Now architecture of numpy itself depends upon lots of factors like
what environment u are using , what about the generation of your laptop too..


But if u want to think it bluntly , they are same..
By the way ,u can cross_check using below code:

import numpy as np
np.dtype('datetime64[ns]') == np.dtype('<M8[ns]')

'''

### convert feature into date-time
### since we have converted feature into date-time using pd.to_datetime() couple of times so lets use astype('datetime64[ns]')

df['Date'] = df['Date'].astype('datetime64[ns]')

## pd.to_datetime()

df['Date'].min()

df['Date'].max()

'''

ie data is collected from "28th April 2013" to "31st July 2017"

'''

df['Date']

### Note : Each row in the "Date" column will belong to timestamp & "Date" Feature data-type will be datetime64[ns]..
## Timestamp is the pandas equivalent of python’s Datetime module..

type(df['Date'][0])

### ie Timestamp is a Scaler Class ..

df.isnull().sum() ## check whether we have missing value or not !

df.duplicated().sum()  ## No duplicated value ..

"""#### Now sort the dataset from oldest - recent"""

df.head(3)

df.tail(5)

data = df.sort_index(ascending=False).reset_index()
data.drop('index' , axis=1 , inplace=True)

"""# 3.. Analysing change in price of the stock overtime?"""

data

data.columns

plt.figure(figsize=(20,12))

for index , col in enumerate(['Open', 'High', 'Low', 'Close'] , 1):
    plt.subplot(2,2,index)
    plt.plot(df['Date'] , df[col])
    plt.title(col)

"""# 4.. Analysing open , high , low , close value of Bitcoin !
    try out candle-stick/ohlc charts ! , both are same ..
"""

data.shape

bitcoin_sample = data[0:50]

### consider sample of data if u dont have good specifications pc/laptop ..

### Lets do proper setup of Plotly so that we can leverage power of Plotly & Cufflinks ..

!pip install chart-studio
!pip install plotly

import chart_studio.plotly as py

import plotly.graph_objs as go

import plotly.express as px

from plotly.offline import download_plotlyjs , init_notebook_mode , plot , iplot

init_notebook_mode(connected=True)

trace = go.Candlestick(x=bitcoin_sample['Date'] ,
              high =bitcoin_sample['High'] ,
              open = bitcoin_sample['Open'] ,
              close = bitcoin_sample['Close'] ,
              low = bitcoin_sample['Low'])

candle_data = [trace]

layout = {
    'title':'Bitcoin Historical Price' ,
    'xaxis':{'title':'Date'}
}

fig = go.Figure(data = candle_data , layout=layout)

fig.update_layout(xaxis_rangeslider_visible = False)
fig.show()

"""# 5.. Analysing closing price (on normal scale & log-scale)"""

data['Close']

data['Close'].plot()

### On above plot , Our x-indices are number , lets first set "date" as your index so that u will get date on "x-indexes"
## as we are using pandas plot "data['Close'].plot()" , so for pandas plot our row indexes must be date ..

data.set_index('Date' , inplace=True)

data

data['Close'].plot()

np.log1p(data['Close']).plot()

plt.figure(figsize=(20,6))

plt.subplot(1,2,1)
data['Close'].plot()
plt.title('No scaling')

plt.subplot(1,2,2)
np.log1p(data['Close']).plot()
plt.title('Log scaling')
plt.yscale('log')

### Logarithmic price scales are better than linear price scales at showing less severe price increases or decreases..

### log scale is always better if u have outliers or some high values in data

'''


Some features of the plot above:

    There is an up-ward trend from 2016 for each graph
    There is no seasonality
    There are no outliers


'''

"""# 6.. Analyse closing Price on Yearly , Quarterly , monthly basis !"""

'''
    Before doing resampling , first u have to make your date feature 'row-index' so that u can resample it in a
    a..yearly('Y')  ,
    b..quarterly('Q')   ,
    c..monthly('M') ,
    d..weekly basis ('W'),
    e..Daily_basis('D')
    f..minutes ('3T') ,
    g..30 second bins('30S')   ,
    h..resample('17min')

'''

data.head(4)

## finding avg price of bitcoin on yearly basis ..

data['Close'].resample('Y').mean()

data['Close'].resample('Y').mean().plot()

## finding avg price of bitcoin on quarterly basis ..

data['Close'].resample('Q').mean()

data['Close'].resample('Q').mean().plot()

## finding avg price of bitcoin on monthly basis ..

data['Close'].resample('M').mean()

data['Close'].resample('M').mean().plot()

"""# 7..  analysing Daily change in Closing price of stocks

##### Daily Stock Return Formula
    To calculate how much you gained or lost per day for a stock, subtract the opening price from the closing price. Then, multiply the result by the number of shares you own in the company.
"""

data['Close']

data['Close_price_pct_change'] = data['Close'].pct_change()*100

data['Close_price_pct_change']

data['Close_price_pct_change'].plot()

'''

If u want to make this Pandas plot interactive , u can think of using cufflinks & Plotly


'''

### establishing the entire set-up of Plotly..

import chart_studio.plotly as py
## chart_studio provides a web-service for hosting graphs!

import plotly.graph_objs as go

import plotly.express as px

from plotly.offline import download_plotlyjs , init_notebook_mode , plot , iplot
init_notebook_mode(connected=True)

## plot is a command of Matplotlib which is more old-school. It creates static charts
## iplot() when working in a Jupyter Notebook to display the plot in the notebook.
## iplot is an interactive plot. Plotly takes Python code and makes beautiful looking JavaScript plots.

import cufflinks as cf

cf.go_offline()

data['Close_price_pct_change']

type(data['Close_price_pct_change'])

fig = px.line(data, y='Close_price_pct_change', title='Daily Percentage Change in Closing Price')
fig.show()